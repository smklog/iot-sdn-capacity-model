"""
iot_sdn_capacity_model.py

IoT & SDN capacity model for a finite resource pool with mixed traffic:

- IoT telemetry sessions (lightweight, 1 unit of capacity)
- Control / management sessions (1 unit, may generate retries)
- Heavy IoT data flows (e.g., firmware updates, bulk analytics uploads)
  that consume multiple capacity units per session

The system is modeled as a full-availability loss system (no queue):
a request either gets capacity immediately or is rejected. Rejected
control sessions generate retry traffic, which is modeled via a
fixed-point iteration. The underlying blocking behavior of the pool is
approximated using the Erlang-B formula.
"""

from __future__ import annotations

from dataclasses import dataclass


def erlang_b(V: int, A: float) -> float:
    """
    Compute Erlang B blocking probability for a full-availability loss system.

    Parameters
    ----------
    V : int
        Number of capacity units in the pool (must be > 0).
    A : float
        Offered load in Erlangs (non-negative).

    Returns
    -------
    float
        Blocking probability B(V, A).

    Notes
    -----
    Uses the classic stable recursion:

        B(0, A) = 1
        B(n, A) = (A * B(n-1, A)) / (n + A * B(n-1, A))

    which avoids large intermediate numbers and factorials.
    """
    if V <= 0:
        raise ValueError("V must be positive")
    if A < 0:
        raise ValueError("A must be non-negative")

    B = 1.0
    for n in range(1, V + 1):
        B = (A * B) / (n + A * B)
    return B


@dataclass
class IoTSdnCapacityParameters:
    """
    Input parameters for the IoT & SDN capacity model.

    All traffic values are in Erlangs and correspond to average offered
    loads over the considered period (e.g. busy hour).

    Attributes
    ----------
    capacity_units : int
        Total number of capacity units managed by the SDN domain.
        This can represent concurrent sessions, flow slots, licenses, etc.
    A_telemetry : float
        Offered load of lightweight IoT telemetry sessions (1 unit each).
    A_control : float
        Offered load of control / management sessions (1 unit each,
        first attempts only, retries are modeled separately).
    A_bulk : float
        Offered load of heavy IoT data flows (firmware updates, bulk uploads).
        Each such flow consumes `bulk_units` capacity units on average.
    bulk_units : int
        Number of capacity units consumed by one heavy flow.
        For example, bulk_units = 2 means each flow uses two units.
    retry_factor : float
        Average number of additional attempts per failed control session.
        Example: retry_factor = 1.0 means one extra attempt on average.
    external_failure_prob : float
        Probability that a session fails outside the SDN domain even if
        capacity is available (e.g., cloud/service-side failure).
    """

    capacity_units: int
    A_telemetry: float
    A_control: float
    A_bulk: float
    bulk_units: int
    retry_factor: float
    external_failure_prob: float

    def validate(self) -> None:
        """Basic input validation."""
        if self.capacity_units <= 0:
            raise ValueError("capacity_units must be positive")
        if self.bulk_units <= 0:
            raise ValueError("bulk_units must be positive")

        for name, value in [
            ("A_telemetry", self.A_telemetry),
            ("A_control", self.A_control),
            ("A_bulk", self.A_bulk),
            ("retry_factor", self.retry_factor),
            ("external_failure_prob", self.external_failure_prob),
        ]:
            if value < 0:
                raise ValueError(f"{name} must be non-negative")

        if not (0.0 <= self.external_failure_prob <= 1.0):
            raise ValueError("external_failure_prob must be in [0, 1]")


@dataclass
class IoTSdnCapacityResults:
    """
    Output metrics of the IoT & SDN capacity model.

    Attributes
    ----------
    A_total : float
        Total offered load to the pool (including retries), Erlangs.
    blocking_prob : float
        Blocking probability of the capacity pool (Erlang-B).
    session_loss_prob : float
        End-to-end loss probability for control sessions (blocked in the
        pool or failed externally).
    retry_load : float
        Load in Erlangs generated by repeated control session attempts.
    carried_traffic : float
        Carried traffic in Erlangs (A_total * (1 - blocking_prob)).
    utilization : float
        Average utilization of the capacity pool (mean busy units / capacity_units).
    iterations : int
        Number of iterations in the fixed-point procedure.
    converged : bool
        True if the fixed-point iteration converged within max_iter.
    """

    A_total: float
    blocking_prob: float
    session_loss_prob: float
    retry_load: float
    carried_traffic: float
    utilization: float
    iterations: int
    converged: bool


def solve_iot_sdn_capacity(
    params: IoTSdnCapacityParameters,
    tol: float = 1e-10,
    max_iter: int = 10_000,
) -> IoTSdnCapacityResults:
    """
    Solve the IoT & SDN capacity model using a fixed-point iteration.

    Algorithm (engineering approximation):

    1. Start with an initial guess for the retry load z = 0.
    2. At each iteration:
       - Compute effective heavy-flow traffic:
             A_bulk_eff = bulk_units * A_bulk
       - Compute total offered load:
             A_total = A_telemetry + A_control + A_bulk_eff + z
       - Compute blocking probability B via Erlang-B.
       - Compute end-to-end loss probability for a control session:
             P_loss = 1 - (1 - B) * (1 - external_failure_prob)
         (either blocked in the pool, or accepted by the pool but
          rejected outside the SDN domain).
       - Update retry load:
             z_new = A_control * retry_factor * P_loss
       - Stop when |z_new - z| is small enough (relative tolerance).

    3. Return the final blocking probabilities and traffic metrics.

    This approach is consistent with classical teletraffic methods for
    loss systems with multi-resource calls and repeated attempts,
    adapted here to IoT & SDN capacity planning.
    """
    params.validate()

    V = params.capacity_units
    A_t = params.A_telemetry
    A_c = params.A_control
    A_b = params.A_bulk
    k_b = params.bulk_units
    k_retry = params.retry_factor
    p_ext = params.external_failure_prob

    # Fixed-point iteration for retry load z
    z = 0.0
    converged = False
    iterations = 0

    for i in range(1, max_iter + 1):
        A_bulk_eff = k_b * A_b
        A_total = A_t + A_c + A_bulk_eff + z

        B = erlang_b(V, A_total)

        # Overall loss for a control session:
        # blocked in the pool OR accepted by the pool,
        # but rejected in the external domain.
        P_loss = 1.0 - (1.0 - B) * (1.0 - p_ext)

        z_new = A_c * k_retry * P_loss

        # Relative convergence check on z
        if abs(z_new - z) <= tol * max(1.0, abs(z_new)):
            z = z_new
            converged = True
            iterations = i
            break

        z = z_new
        iterations = i

    # Final metrics with converged (or last) z
    A_bulk_eff = k_b * A_b
    A_total = A_t + A_c + A_bulk_eff + z
    B = erlang_b(V, A_total)
    P_loss = 1.0 - (1.0 - B) * (1.0 - p_ext)
    carried = A_total * (1.0 - B)
    utilization = carried / V

    return IoTSdnCapacityResults(
        A_total=A_total,
        blocking_prob=B,
        session_loss_prob=P_loss,
        retry_load=z,
        carried_traffic=carried,
        utilization=utilization,
        iterations=iterations,
        converged=converged,
    )


if __name__ == "__main__":
    # Example scenario: SDN-controlled IoT domain
    example_params = IoTSdnCapacityParameters(
        capacity_units=500,      # total capacity units in the pool
        A_telemetry=200.0,       # IoT telemetry load (Erlangs)
        A_control=50.0,          # control / management load (Erlangs)
        A_bulk=40.0,             # heavy IoT flows (Erlangs)
        bulk_units=2,            # each heavy flow uses 2 units of capacity
        retry_factor=0.3,        # average retries per failed control session
        external_failure_prob=0.1,  # external failure probability
    )

    results = solve_iot_sdn_capacity(example_params)

    print("=== IoT & SDN Capacity Model Results ===")
    print(f"Converged:            {results.converged}")
    print(f"Iterations:           {results.iterations}")
    print(f"Total offered A:      {results.A_total:.4f} Erlangs")
    print(f"Blocking (Erlang-B):  {results.blocking_prob:.6e}")
    print(f"Session loss prob:    {results.session_loss_prob:.6e}")
    print(f"Retry load z*:        {results.retry_load:.4f} Erlangs")
    print(f"Carried traffic:      {results.carried_traffic:.4f} Erlangs")
    print(f"Utilization (A/V):    {results.utilization:.4f}")
